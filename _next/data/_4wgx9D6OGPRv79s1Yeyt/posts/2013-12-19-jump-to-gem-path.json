{"pageProps":{"post":{"id":"2013-12-19-jump-to-gem-path","title":"Vim中級者を脱する path編","date":"2013-12-19 08:02","content":"<p>はい、pathとは<code>:set path</code>で出てくるやつのことです。\n実際にはみなさん<code>gf</code>やファイル補完などでお世話になっていると思います。</p>\n<p>今回はpathとは何かを説明して、.rbファイルのクラスからGemの定義元へ飛ぶ方法をやってみましょう。</p>\n<!-- more -->\n<p><strong>方法だけ知りたい人は、一番下までスクロールしてください</strong></p>\n<h1>pathとは？</h1>\n<p>Vimにおけるpathとは、<code>set path?</code>で出てくるpathです。</p>\n<p>適当にファイルを開いてコマンドを打ってみましょう。</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">:set path?\npath=.,/usr/include</code></pre></div>\n<p>これを設定しておくことで何が嬉しいかというと、編集中の変数の定義元へ飛べたり、ファイルを検索出来たりします。つまるところ、Vimが<em>何かを探すときの基準になる</em>ディレクトリ達を指定することができます。</p>\n<p>補完プラグインや、Vimの基本機能などもpathに依存していることが多いため、裏側では結構活躍している設定でもあります。</p>\n<h2><code>gf</code>でGemの定義元に飛ぶ</h2>\n<p><code>gf</code>は通常、カーソル</p>\n<p>Rubyを編集する際、Vimのビルトインの<code>ftplugin/ruby.vim</code>が読み込まれ、<code>gf</code>が自動的に関数にマッピングされます。</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">:set filetype=ruby\n:nmap gf\nn  gf          *@:&#x26;lt;C-U&#x26;gt;exe &#x26;lt;SNR&#x26;gt;121_gf(v:count1,&#x26;quot;gf&#x26;quot;,&#x26;#39;edit&#x26;#39;)&#x26;lt;CR&#x26;gt;</code></pre></div>\n<p>このおかげで、通常の<code>gf</code>が拡張されて幾つかのケースで<code>gf</code>が使えるようになります。(Rails.vimも同じ手法を使っていますね。)</p>\n<p>具体的には<code>require 'path/to/file'</code>やload, autoloadで書いたファイルパスへ飛ぶことができます。</p>\n<p>内部では拡張子を取り除いたり、ファイル名に不要な文字を変換したりしていますが、そのオプションについては、今回は割愛します。</p>\n<h3>pathにRubyのload_pathを追加する</h3>\n<p>Rubyを編集中に、Gemの定義元へ移動する話をしましょう。</p>\n<p>まずRubyについて理解しておく必要があるのは、load_pathの仕組みです。Rubyは<code>require</code>などを使用したときに、指定されたファイルを<code>$LOAD_PATH</code>のディレクトリ一覧の中から探します。</p>\n<p>下記のようなコマンドを打つことで、デフォルトの$LOAD_PATHを探すことができます。</p>\n<div class=\"remark-highlight\"><pre class=\"language-ruby\"><code class=\"language-ruby\">ruby <span class=\"token operator\">-</span>e <span class=\"token string-literal\"><span class=\"token string\">'puts $LOAD_PATH'</span></span>\n</code></pre></div>\n<p>Gemfileを定義した場合、この$LOAD_PATHにそれらのGemの場所が追加されるので<code>require</code>で使うことがきるようになるんですね。</p>\n<p>それでは、VimにもGemfileから取ってきたディレクトリ一覧を与えてやることで、定義元を探し出せるようにしましょう。</p>\n<h3>Gemfileからディレクトリ一覧を取り出す</h3>\n<p><code>bundle show --paths</code>を使うことで、一覧情報を取り出せます。</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">$ bundle show --paths\n/Users/alpaca-tc/.rbenv/versions/2.0.0-p247/lib/ruby/gems/2.0.0/gems/RedCloth-4.2.9\n/Users/alpaca-tc/.rbenv/versions/2.0.0-p247/lib/ruby/gems/2.0.0/gems/bundler-1.3.5\n/Users/alpaca-tc/.rbenv/versions/2.0.0-p247/lib/ruby/gems/2.0.0/gems/chunky_png-1.2.5\n...</code></pre></div>\n<p>この情報を<code>setl path=...</code>と与えてやれば、<code>gf</code>を使って定義元に飛べるようになります。</p>\n<h3><code>set path=</code>を使って定義する</h3>\n<p><a href=\"https://gist.github.com/8031905\">こちらのスクリプト</a>をvimrcに貼付けましょう。<a href=\"https://github.com/vim-jp/vital.vim\">vital.vim</a>依存です(unite.vim, neocompleteがあれば動作します)</p>\n<p>これで、GemPathを読み込む<code>:LoadGem</code>というコマンドが作られます。</p>\n<p>下記のような動作で定義元に飛べるのが確認できると思います。</p>\n<img class=\"image_on_frame center\" src=\"/images/blog/jump-to-gem-path/hM4zx40RmT.gif\" alt=\"gemジャンプデモ\" />\n<p>無事動いていますね。</p>\n<h2>まとめ</h2>\n<p>今回はpathについて、簡単に説明しました。</p>\n<p>次回は、pathを活用してさらに<code>include</code>, <code>includeexpr</code>あたりをやります。</p>\n<p>この辺を勉強すると、自分の環境用にファイル補完を作り上げられます。 neocompleteのfile/includeあたりが書けるようになりますよ〜</p>","rawContent":"\nはい、pathとは`:set path`で出てくるやつのことです。\n実際にはみなさん`gf`やファイル補完などでお世話になっていると思います。\n\n今回はpathとは何かを説明して、.rbファイルのクラスからGemの定義元へ飛ぶ方法をやってみましょう。\n\n<!-- more -->\n\n**方法だけ知りたい人は、一番下までスクロールしてください**\n\n# pathとは？\n\nVimにおけるpathとは、`set path?`で出てくるpathです。\n\n適当にファイルを開いてコマンドを打ってみましょう。\n\n```\n:set path?\npath=.,/usr/include\n```\n\nこれを設定しておくことで何が嬉しいかというと、編集中の変数の定義元へ飛べたり、ファイルを検索出来たりします。つまるところ、Vimが*何かを探すときの基準になる*ディレクトリ達を指定することができます。\n\n補完プラグインや、Vimの基本機能などもpathに依存していることが多いため、裏側では結構活躍している設定でもあります。\n\n## `gf`でGemの定義元に飛ぶ\n\n`gf`は通常、カーソル\n\nRubyを編集する際、Vimのビルトインの`ftplugin/ruby.vim`が読み込まれ、`gf`が自動的に関数にマッピングされます。\n\n```\n:set filetype=ruby\n:nmap gf\nn  gf          *@:<C-U>exe <SNR>121_gf(v:count1,\"gf\",'edit')<CR>\n```\n\nこのおかげで、通常の`gf`が拡張されて幾つかのケースで`gf`が使えるようになります。(Rails.vimも同じ手法を使っていますね。)\n\n具体的には`require 'path/to/file'`やload, autoloadで書いたファイルパスへ飛ぶことができます。\n\n内部では拡張子を取り除いたり、ファイル名に不要な文字を変換したりしていますが、そのオプションについては、今回は割愛します。\n\n### pathにRubyのload\\_pathを追加する\n\nRubyを編集中に、Gemの定義元へ移動する話をしましょう。\n\nまずRubyについて理解しておく必要があるのは、load_pathの仕組みです。Rubyは`require`などを使用したときに、指定されたファイルを`$LOAD_PATH`のディレクトリ一覧の中から探します。\n\n下記のようなコマンドを打つことで、デフォルトの$LOAD_PATHを探すことができます。\n\n```ruby\nruby -e 'puts $LOAD_PATH'\n```\n\nGemfileを定義した場合、この$LOAD_PATHにそれらのGemの場所が追加されるので`require`で使うことがきるようになるんですね。\n\nそれでは、VimにもGemfileから取ってきたディレクトリ一覧を与えてやることで、定義元を探し出せるようにしましょう。\n\n### Gemfileからディレクトリ一覧を取り出す\n\n`bundle show --paths`を使うことで、一覧情報を取り出せます。\n\n```\n$ bundle show --paths\n/Users/alpaca-tc/.rbenv/versions/2.0.0-p247/lib/ruby/gems/2.0.0/gems/RedCloth-4.2.9\n/Users/alpaca-tc/.rbenv/versions/2.0.0-p247/lib/ruby/gems/2.0.0/gems/bundler-1.3.5\n/Users/alpaca-tc/.rbenv/versions/2.0.0-p247/lib/ruby/gems/2.0.0/gems/chunky_png-1.2.5\n...\n```\n\nこの情報を`setl path=...`と与えてやれば、`gf`を使って定義元に飛べるようになります。\n\n### `set path=`を使って定義する\n\n[こちらのスクリプト](https://gist.github.com/8031905)をvimrcに貼付けましょう。[vital.vim](https://github.com/vim-jp/vital.vim)依存です(unite.vim, neocompleteがあれば動作します)\n\nこれで、GemPathを読み込む`:LoadGem`というコマンドが作られます。\n\n下記のような動作で定義元に飛べるのが確認できると思います。\n\n<img class=\"image_on_frame center\" src=\"/images/blog/jump-to-gem-path/hM4zx40RmT.gif\" alt=\"gemジャンプデモ\" />\n\n無事動いていますね。\n\n## まとめ\n\n今回はpathについて、簡単に説明しました。\n\n次回は、pathを活用してさらに`include`, `includeexpr`あたりをやります。\n\nこの辺を勉強すると、自分の環境用にファイル補完を作り上げられます。 neocompleteのfile/includeあたりが書けるようになりますよ〜\n"},"prevPost":{"id":"2013-12-25-gyaku-syuukatsu-1","title":"逆就活へ参加するときのノウハウまとめ","date":"2013-12-25 23:23"},"nextPost":{"id":"2013-12-17-how-to-use-vim-unite-giti","title":"仕事が捗る！VimからGitを使う最適解","date":"2013-12-17 23:36"}},"__N_SSG":true}